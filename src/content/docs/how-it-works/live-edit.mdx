---
title: "Live Collaboration & Real-time Synchronization"
description: "How peers establish real-time editing sessions and maintain synchronized document states"
---

When users open shared documents in Osvauld, the system automatically discovers collaborators and attempts to establish real-time editing sessions. This process enables immediate synchronization of every keystroke while maintaining connection resilience and handling document switching gracefully.

## Connection Establishment for Collaboration

When a user opens a shared document, the system triggers a collaborative session setup process that discovers potential collaborators and establishes connections for real-time editing.

### Shared User Discovery

The document opening process queries the local database to find all users who have access to the current document, along with their associated devices:

import { Image } from 'astro:assets';
import sharedUserDiscovery from '../../../assets/diagrams/shared-user-discovery.webp';

<Image src={sharedUserDiscovery} alt="Shared user discovery flow diagram showing document opening, user discovery, connection requests, and state management" />

### Connection State Categories

The system maintains two distinct categories of peer connections:

**Active Connections**: Peers currently editing the same document who receive immediate updates for every keystroke and change.

**Inactive Connections**: Peers who are connected but editing different documents, who receive periodic state synchronization updates.

This categorization enables efficient resource usage by sending real-time updates only to collaborators who need them while maintaining document consistency across all connected peers.

## Document Check Protocol

When connections are established, peers must verify whether they're editing the same document before enabling real-time synchronization. This verification prevents unnecessary real-time updates between peers working on different documents.

### Document Verification Process

import documentVerificationProcess from '../../../assets/diagrams/document-verification-process.webp';

<Image src={documentVerificationProcess} alt="Document verification process flow diagram showing document check initiation, peer verification, state vector exchange, and connection categorization" />

### Document Check Message Flow

The document verification uses a specific message protocol:

**DocumentCheck**: Sent by the connection initiator with the current `resource_id`
**DocumentCheckResponse**: Peer responds with `is_match` boolean and `state_vectors` if matched
**StateVectorExchange**: If matched, begin immediate CRDT synchronization
**UpdateExchange**: Bidirectional update exchange for state convergence

This protocol ensures that peers only engage in expensive real-time synchronization when they're actually collaborating on the same document.

## Real-time Synchronization

Once peers are categorized as active connections (editing the same document), every change is immediately broadcast to maintain synchronized document states across all collaborators.

### Keystroke-Level Collaboration

import keystrokeLevelCollaboration from '../../../assets/diagrams/keystroke-level-collaboration.webp';

<Image src={keystrokeLevelCollaboration} alt="Keystroke-level collaboration flow diagram showing user input events, update broadcasting, and remote application processing" />

### Real-time Message Types

The system uses specific message types for different aspects of real-time collaboration:

**DocumentUpdate**: Contains CRDT operations for document content changes, client ID, and document type
**AwarenessUpdate**: Contains cursor position, selection state, and user presence information

Both message types are sent immediately upon local changes and applied directly to peer's document states, ensuring sub-second synchronization across all active collaborators.

## Connection Resilience and Reconciliation

The system includes multiple mechanisms to maintain stable collaboration sessions even when network conditions are poor or connections are temporarily lost.

### Periodic Reconciliation

import periodicReconciliation from '../../../assets/diagrams/periodic-reconciliation.webp';

<Image src={periodicReconciliation} alt="Periodic reconciliation flow diagram showing reconciliation timer, state vector reconciliation, connection health validation, and automatic recovery" />

### Connection Health Monitoring

The system continuously monitors connection health through:

**Message Send Monitoring**: Failed message sends immediately trigger reconnection attempts
**QUIC Connection Status**: Regular checks of underlying connection state
**Timeout Detection**: Connections that become unresponsive are marked for recovery

Failed connections are automatically removed from active connection lists and reconnection attempts are made asynchronously, ensuring that temporary network issues don't disrupt collaboration for other peers.

## Document Switching and State Cleanup

When users switch between documents, the system must gracefully handle connection state transitions and ensure all peers receive final synchronization updates before transitioning to new collaboration contexts.

### Document Switch Protocol

```d2
vars: {
  d2-config: {
    layout-engine: elk
  }
  colors: {
    switch_trigger: "#e1f5fe"
    switch_trigger_border: "#0277bd"
    cleanup_active: "#f3e5f5"
    cleanup_active_border: "#7b1fa2"
    sync_inactive: "#e8f5e8"
    sync_inactive_border: "#2e7d32"
    transition: "#fce4ec"
    transition_border: "#c2185b"
    main_flow: "#1976d2"
  }
}

switch_trigger_section: "Document Switch Trigger" {
  style: {
    font-size: 40
    font-color: black
    stroke-width: 3
    fill: ${colors.switch_trigger}
    stroke: ${colors.switch_trigger_border}
  }
  
  grid-rows: 1
  grid-columns: 3
  
  user_switch: "User Switches Document" {
    style.font-size: 34
    style.font-color: black
    width: 280
    "Select different document\nClose current document\nTrigger note-change event": {
      style.font-size: 32
    }
  }
  
  detect_change: "Detect Document Change" {
    style.font-size: 34
    style.font-color: black
    width: 280
    "Compare previous vs new resource_id\nIdentify actual document switch\nSkip if same document": {
      style.font-size: 32
    }
  }
  
  initiate_cleanup: "Initiate Cleanup Process" {
    style.font-size: 34
    style.font-color: black
    width: 280
    "Handle previous document connections\nPrepare for new document setup\nMaintain connection state": {
      style.font-size: 32
    }
  }
  
  user_switch -> detect_change -> initiate_cleanup: {
    style.stroke-width: 2
    style.stroke: ${colors.switch_trigger_border}
  }
}

cleanup_active_section: "Active Connection Cleanup" {
  style: {
    font-size: 40
    font-color: black
    stroke-width: 3
    fill: ${colors.cleanup_active}
    stroke: ${colors.cleanup_active_border}
  }
  
  grid-rows: 1
  grid-columns: 4
  
  get_active_connections: "Get Active Connections" {
    style.font-size: 34
    style.font-color: black
    width: 250
    "Retrieve list of active collaborators\nPeers currently editing same document\nConnections needing notification": {
      style.font-size: 32
    }
  }
  
  send_document_changed: "Send DocumentChanged" {
    style.font-size: 34
    style.font-color: black
    width: 250
    "Notify each active peer\nLiveEditMessage::DocumentChange\nSignal document switch": {
      style.font-size: 32
    }
  }
  
  peer_response: "Peer Response Handling" {
    style.font-size: 34
    style.font-color: black
    width: 250
    "Peers move connection to inactive\nStop sending real-time updates\nMaintain connection for future": {
      style.font-size: 32
    }
  }
  
  clear_active_list: "Clear Active List" {
    style.font-size: 34
    style.font-color: black
    width: 250
    "Remove all active connections\nStop real-time broadcasting\nPrepare for new document": {
      style.font-size: 32
    }
  }
  
  get_active_connections -> send_document_changed -> peer_response -> clear_active_list: {
    style.stroke-width: 2
    style.stroke: ${colors.cleanup_active_border}
  }
}

sync_inactive_section: "Inactive Connection Sync" {
  style: {
    font-size: 40
    font-color: black
    stroke-width: 3
    fill: ${colors.sync_inactive}
    stroke: ${colors.sync_inactive_border}
  }
  
  grid-rows: 1
  grid-columns: 4
  
  get_inactive_connections: "Get Inactive Connections" {
    style.font-size: 34
    style.font-color: black
    width: 250
    "Retrieve inactive connection list\nPeers on different documents\nConnections needing final sync": {
      style.font-size: 32
    }
  }
  
  generate_state_vectors: "Generate Final State Vectors" {
    style.font-size: 34
    style.font-color: black
    width: 250
    "Get current document state\nExtract Yjs state vectors\nPrepare final synchronization": {
      style.font-size: 32
    }
  }
  
  broadcast_state_request: "Broadcast State Vector Request" {
    style.font-size: 34
    style.font-color: black
    width: 250
    "Send to all inactive connections\nResourceUpdateMsg::StateVectorRequest\nEnsure final consistency": {
      style.font-size: 32
    }
  }
  
  complete_sync: "Complete Background Sync" {
    style.font-size: 34
    style.font-color: black
    width: 250
    "Standard resource sync protocol\nUpdatesResponse + FinalUpdateMerge\nMaintain document consistency": {
      style.font-size: 32
    }
  }
  
  get_inactive_connections -> generate_state_vectors -> broadcast_state_request -> complete_sync: {
    style.stroke-width: 2
    style.stroke: ${colors.sync_inactive_border}
  }
}

transition_section: "Document Transition" {
  style: {
    font-size: 40
    font-color: black
    stroke-width: 3
    fill: ${colors.transition}
    stroke: ${colors.transition_border}
  }
  
  grid-rows: 1
  grid-columns: 3
  
  clear_all_connections: "Clear All Connection Lists" {
    style.font-size: 34
    style.font-color: black
    width: 280
    "Reset active connections\nReset inactive connections\nClean slate for new document": {
      style.font-size: 32
    }
  }
  
  load_new_document: "Load New Document" {
    style.font-size: 34
    style.font-color: black
    width: 280
    "Set new current document\nLoad CRDT states\nPrepare for collaboration": {
      style.font-size: 32
    }
  }
  
  restart_collaboration: "Restart Collaboration Setup" {
    style.font-size: 34
    style.font-color: black
    width: 280
    "Discover new shared users\nSend live edit requests\nBegin new collaboration session": {
      style.font-size: 32
    }
  }
  
  clear_all_connections -> load_new_document -> restart_collaboration: {
    style.stroke-width: 2
    style.stroke: ${colors.transition_border}
  }
}

switch_trigger_section -> cleanup_active_section -> sync_inactive_section -> transition_section: {
  style.stroke-width: 4
  style.stroke: ${colors.main_flow}
}
```

### State Transition Management

During document switching, the system maintains connection state carefully:

**Active → Inactive Transition**: Active collaborators are notified via DocumentChange messages and automatically moved to inactive status, stopping real-time updates but preserving the connection.

**Final Synchronization**: Inactive connections receive final state vector synchronization to ensure they have the most recent document state before the user switches away.

**Connection Preservation**: Established QUIC connections are preserved across document switches, allowing for efficient reconnection when users return to shared documents.

### Document Switch Edge Cases

The system handles several edge cases during document switching:

**Same Document Switch**: If the user "switches" to the same document, the system detects this and skips the cleanup process entirely.

**Null Document**: When closing all documents, the system clears all connection lists and stops collaboration processes.

**Failed Notifications**: If DocumentChange notifications fail to send, the system continues with cleanup to prevent hanging in inconsistent states.

## Message Protocol Summary

The live collaboration system uses a comprehensive message protocol built on the existing P2P infrastructure:

### Core Message Types

```rust
pub enum LiveEditMessage {
    DocumentCheck {
        resource_id: String,
    },
    StateVectorExchange {
        resource_id: String,
        state_vectors: String,
    },
    UpdateExchange {
        resource_id: String,
        updates: String,
    },
    UpdateExchangeResponse {
        resource_id: String,
        updates: String,
    },
    NotSameDocument,
    DocumentChange {
        resource_id: String,
    },
    DocumentUpdate {
        updates: Vec<u8>,
        resource_id: String,
        client_id: u32,
        doc_type: String,
    },
    AwarenessUpdate {
        resource_id: String,
        client_id: u32,
        awareness_data: Vec<u8>,
    },
}
```

### Message Flow Patterns

**Connection Establishment**: DocumentCheck → StateVectorExchange → UpdateExchange → UpdateExchangeResponse

**Real-time Collaboration**: DocumentUpdate (continuous) + AwarenessUpdate (continuous)

**Periodic Reconciliation**: StateVectorExchange → UpdateExchange → UpdateExchangeResponse

**Document Switching**: DocumentChange → connection state transitions

**Connection Recovery**: Automatic reconnection → DocumentCheck → full synchronization

## System Architecture Benefits

This live collaboration architecture provides several key advantages:

**Immediate Responsiveness**: Keystroke-level synchronization provides Google Docs-like collaboration experience without central servers.

**Network Efficiency**: Only active collaborators receive real-time updates, while inactive connections use efficient periodic sync.

**Connection Resilience**: Automatic reconnection and reconciliation ensure collaboration sessions survive network disruptions.

**Resource Optimization**: Connection state management prevents unnecessary processing and network usage.

**Scalable Collaboration**: The system supports multiple simultaneous collaboration sessions across different documents with proper resource isolation.

The combination of real-time updates, connection resilience, and efficient state management creates a robust collaborative editing experience that operates entirely through peer-to-peer connections without requiring central coordination servers.
