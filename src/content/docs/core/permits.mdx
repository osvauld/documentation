---
title: "Permits - Decentralized Authorization"
description: "Understanding how Permits provide smart contract-like authorization for the Extended Web"
---

## What Are Permits?

**Permits are to the Extended Web what smart contracts are to blockchain** - decentralized, cryptographic, programmable authorization.

Just as smart contracts execute authorization logic on blockchain without centralized servers, Permits execute authorization logic in peer-to-peer applications without permission servers.

### Evolution from UCAN

Permits evolved from UCAN (User Controlled Authorization Networks) into a facts-only, data-driven design specifically for the Extended Web.

**UCAN** = The standard for decentralized authorization tokens

**Permits** = Our implementation with:
- Facts-only architecture (all data in `fct` field)
- Data-driven behavior (frontend defines templates, backend reads dynamically)
- Document-level permissions (not user roles)
- Integration with HUML templates and CEL expressions

## Bearer Token Architecture

Permits are **bearer tokens** - anyone holding a valid Permit is authorized to use it.

### How Traditional Authorization Works

**Traditional systems**:
1. User presents credentials (username/password)
2. Server checks database: "Does this user have permission?"
3. Server grants or denies access

**Central authority required** - every operation queries the server.

### How Permit Authorization Works

**Extended Web**:
1. User presents Permit (cryptographically signed token)
2. Peer verifies signature (mathematical proof it's authentic)
3. Peer reads facts from Permit (what operations are allowed)
4. Peer grants access based on facts

**No central authority needed** - verification is purely cryptographic.

### The Smart Contract Analogy

| Blockchain Smart Contracts | Extended Web Permits |
|----------------------------|---------------------|
| Self-executing code on blockchain | Self-contained authorization in tokens |
| Read blockchain state to decide actions | Read Permit facts to decide operations |
| No central authority validates execution | No permission server validates access |
| Cryptographically verified | Cryptographically signed and verified |
| Programmable with code | Programmable with facts and templates |

Permits provide the same decentralization for personal applications that smart contracts provide for blockchain applications.

## Permit Structure

Permits use a **facts-only** architecture where all authorization data lives in the `fct` (facts) field.

### Example: Folder Owner Permit

```json
{
  "iss": "did:key:z6Mkf...",  // Issuer (who created this)
  "aud": "did:key:z6Mkf...",  // Audience (who it's for)
  "exp": 1234567890,          // Expiration timestamp
  "fct": {
    // Facts field - all authorization data here
    "folder_id": "550e8400-...",
    "operations": {
      "own": "allow",
      "get_share_link": "allow",
      "add_resources": "allow",
      "share_folder": "allow"
    },
    "delegation": {
      // Templates for further delegation
      "node": {
        "operations": {
          "get_share_link": "allow",
          "add_resources": "allow",
          "share_folder": "allow"
        },
        "auth_capabilities": {
          "can_connect": true,
          "persist_share": true,
          "sync_enabled": true
        }
      },
      "viewer": {
        "operations": {
          "request_resources": "allow"
        },
        "auth_capabilities": {
          "can_connect": true,
          "persist_share": false,
          "sync_enabled": false
        }
      }
    }
  },
  "prf": []  // Proof chain (empty for root tokens)
}
```

### Key Components

**Standard UCAN Fields**:
- `iss` - Issuer's DID (Decentralized Identifier)
- `aud` - Audience's DID (who this Permit authorizes)
- `exp` - Expiration timestamp
- `prf` - Proof chain (links to parent Permits)

**Facts Field (`fct`)**:
- `operations` - What actions are allowed
- `documents` - Per-document capabilities (for resources)
- `delegation` - Templates for creating child Permits
- `sync` - Sync behavior facts
- Future: `cel_rules` - Dynamic validation expressions

Everything the system needs to make authorization decisions is in the facts.

## Data-Driven, Not Hardcoded

The backend doesn't have hardcoded role logic. Instead, it reads Permit facts dynamically.

### Traditional Approach (What We DON'T Do)

```rust
// ❌ Hardcoded roles in backend
if user.role == "owner" {
    allow_operation("add_resources");
} else if user.role == "viewer" {
    deny_operation("add_resources");
}
```

### Extended Web Approach (Data-Driven)

```rust
// ✅ Read from Permit facts
let permit = Permit::from_token(&token)?;

if permit.has_operation("add_resources") {
    // Permit facts say they can do this
    allow_operation();
} else {
    deny_operation();
}
```

**The backend has no concept of "owner" or "viewer" roles** - it only reads facts from Permits and validates cryptographic signatures.

### Where Templates Are Defined

**Frontend defines all permission templates** in TypeScript:

```typescript
// frontend/src/config/permissions.ts
export const FOLDER_TEMPLATE = {
  owner_template: {
    operations: {
      "own": "allow",
      "add_resources": "allow",
      "share_folder": "allow"
    },
    delegation: {
      node: {
        operations: {
          "add_resources": "allow",
          "share_folder": "allow"
        }
      },
      viewer: {
        operations: {
          "request_resources": "allow"
        }
      }
    }
  }
};
```

**Frontend sends template to backend** when creating folders/resources

**Backend embeds template** in the Permit's `fct.delegation` field

**Later delegation reads template** - no hardcoded logic required

This makes the system infinitely flexible - new permission models don't require backend code changes.

## Document-Level Permissions

Permits use **document-level permissions**, not user roles, because the same person needs different permissions on different documents.

### The Problem with User Roles

Consider a publishing app with multiple documents per resource:

```
Resource: "My Blog Post"
├─ template_doc (layout and structure)
├─ content_doc (the actual blog post)
├─ collaborative_doc (public comments)
├─ submissions_doc (form responses)
└─ user_content_doc (private user data)
```

**The same viewer needs**:
- **Read-only** on `template_doc` and `content_doc`
- **Collaborative** on `collaborative_doc` (can add comments)
- **Append-only** on `submissions_doc` (can submit, can't see others)
- **Private** on `user_content_doc` (only they can see their data)

User roles can't express this nuance. You need per-document capabilities.

### Resource Permit with Document Permissions

```json
{
  "fct": {
    "resource_id": "abc-123",
    "documents": {
      "template_doc": {
        "capability": "viewer",  // Read-only
        "type": "loro"
      },
      "content_doc": {
        "capability": "viewer"  // Read-only
      },
      "collaborative_doc": {
        "capability": "collaborator"  // Can edit!
      }
      // submissions_doc and user_content_doc NOT included for viewers
    },
    "sync": {
      "local_only": ["user_content_doc"],  // Never syncs to others
      "send_full_snapshot": ["submissions_doc"]  // Full doc, not deltas
    }
  }
}
```

**Document filtering in delegation templates** determines what documents each relationship can access.

## The Three Capabilities

Permits define three levels of document access:

### 1. Viewer (Read-Only)

**What they can do**:
- Read document content
- Receive updates when publisher makes changes
- Render content locally

**What they can't do**:
- Modify content
- Send changes back to publisher

**Use case**: Blog readers, newsletter subscribers, public content viewers

### 2. Submitter (Append-Only)

**What they can do**:
- Add new content (append operations)
- Submit forms, post comments
- Cannot see others' submissions

**What they can't do**:
- Edit existing content
- Delete content
- See what others submitted

**Use case**: Form submissions, surveys, feedback collection

### 3. Collaborator (Read-Write)

**What they can do**:
- Read and write content
- Make edits that sync to others
- Collaborate in real-time

**What they can't do**:
- Whatever the delegation template doesn't grant

**Use case**: Collaborative editing, group threads, shared workspaces

**Same person, different capabilities** - a viewer might be read-only on one document but collaborator on another.

## Delegation Templates

Templates enable **autonomous delegation** - peers can create child Permits without the original issuer being involved.

### How Delegation Works

1. **Owner creates folder with Permit**
   - Permit includes `delegation.node` and `delegation.viewer` templates
   - Templates define what node and viewers can do

2. **Owner delegates to node**
   - Backend reads `delegation.node` template from owner's Permit
   - Creates new Permit for node with those capabilities
   - Node now has its own Permit

3. **Node delegates to viewer**
   - Backend reads `delegation.viewer` template from node's Permit
   - Creates new Permit for viewer with viewer capabilities
   - **Owner doesn't need to be online** for this!

### Autonomous Node Operation

This is why nodes can onboard viewers without owner involvement:

```
Owner's Permit (root)
└─ delegation.node template
   └─ delegation.viewer template (embedded)
```

When viewer requests access:
1. Node extracts `delegation.viewer` template from its Permit
2. Creates viewer Permit using template
3. Signs with node's key
4. Viewer gets access

**Owner never involved** in viewer onboarding - the delegation template authorized the node to do this.

## Infinite Customization

Because Permits are data-driven and read from HUML templates, you can create unlimited permission combinations.

### Example Use Cases

**Public Publishing**:
- Document names: `content_doc`, `comments_doc`
- Viewers: read-only on content, collaborator on comments

**Private Messaging**:
- Document names: `messages_doc`, `presence_doc`
- All participants: collaborator on both

**Password Management**:
- Document names: `vault_doc`, `shared_secrets_doc`
- Owner: collaborator on both
- Viewers: viewer on `shared_secrets_doc` only

**Interactive Games**:
- Document names: `game_state_doc`, `player_actions_doc`
- Players: collaborator on `player_actions_doc`, viewer on `game_state_doc`

**Custom Workflows**:
- Define your own document names in HUML templates
- Specify capabilities per document
- Frontend reads Permits to determine behavior

The system doesn't care what you name your documents or what capabilities you assign - it just reads the facts and behaves accordingly.

## Security Properties

### Cryptographic Verification

Every Permit is cryptographically signed. Validation:
1. Extract issuer's DID from Permit
2. Get public key from DID
3. Verify signature with public key
4. Check expiration timestamp
5. Validate proof chain (if delegated)

**No trust in servers** - pure mathematical verification.

### Forward Secrecy

When delegating, content is re-encrypted for each recipient using their PGP public key.

Compromising one Permit doesn't reveal:
- Content from other delegations
- Parent Permit's capabilities
- Sibling Permits in the delegation tree

Each delegation is cryptographically isolated.

### Bearer Token Security

One-time bearer tokens (used in handshakes) are ephemeral - immediately replaced with long-lived Permits after trust establishment.

Long-lived Permits include:
- Expiration timestamps
- Audience restrictions (specific DIDs)
- Proof chains for validation

### Proof Chains

Delegated Permits link back to root authority:

```
Owner's Permit (root, self-signed)
  ↓ (prf field contains parent CID)
Node's Permit (delegated from owner)
  ↓ (prf field contains parent CID)
Viewer's Permit (delegated from node)
```

Anyone can verify the entire chain cryptographically without asking the original issuer.

## Why This Matters

Permits enable decentralized authorization that works like smart contracts:

**No permission servers** - Verification is cryptographic, not database lookups

**Autonomous delegation** - Peers can delegate without involving original issuers

**Infinite flexibility** - Data-driven design supports any permission model

**Offline-capable** - Validation works without network connectivity

**Auditable** - Proof chains provide transparent history

**Customizable** - HUML templates define document names and capabilities

This is what makes the Extended Web truly sovereign - authorization doesn't depend on anyone's server staying online or being willing to serve you.

**Permits are the smart contracts of personal sovereignty.**
