---
title: "Synchronization Protocol"
description: "How Permit-driven sync enables conflict-free collaboration in the Extended Web"
---

## Permit-Driven Synchronization

In the Extended Web, synchronization is entirely driven by Permits. Every sync decision - what to send, who can receive, how to merge - comes from Permit facts, not hardcoded logic.

This is fundamentally different from traditional sync systems.

### Traditional Approach (Hardcoded)

```javascript
// ❌ Hardcoded sync logic
if (user.role === "owner") {
  sendAllDocuments();
} else if (user.role === "viewer") {
  sendOnlyPublicDocuments();
}
```

### Extended Web Approach (Data-Driven)

```javascript
// ✅ Permit-driven sync
const syncContext = new SyncContext(ourPermit, peerPermit);

for (const docName of resource.documentNames()) {
  const decision = shouldSendUpdates(syncContext, docName);

  switch (decision) {
    case "dont_send":
      continue;  // Skip this document
    case "send_full":
      sendFullSnapshot(doc);  // Send complete history
    case "send_incremental":
      sendIncrementalUpdates(doc);  // Send current state
  }
}
```

**The system reads Permit facts to determine behavior** - no hardcoded role logic.

## Dual-Permit Validation

The key insight: **sync requires TWO Permits** - yours and your peer's.

### Why Two Permits?

When syncing, you need to answer both:
1. **Can I send this?** (check your Permit)
2. **Can they receive this?** (check their Permit)

If either answer is "no," the document doesn't sync.

### SyncContext - The Intersection

`SyncContext` holds both Permits and validates them together:

```
Your Permit says: "I can send template_doc"
Their Permit says: "I can receive template_doc"
→ Send template_doc ✅

Your Permit says: "I can send user_content_doc"
Their Permit says: "I cannot receive user_content_doc"
→ Don't send user_content_doc ❌

Your Permit says: "user_content_doc is local_only"
Their Permit says: "I can receive user_content_doc"
→ Don't send user_content_doc ❌ (your restriction wins)
```

**Both Permits must agree** for sync to happen. This ensures:
- You don't accidentally send private documents
- Peers can't request documents they're not authorized to see
- Sync behavior is always the intersection of both permissions

## Document-Level Filtering

Synchronization happens per-document, not per-resource. Each document can have different sync behavior.

### Example: Publishing Platform

```
Resource: "Blog Post"
├─ template_doc → Send to viewers (they need layout)
├─ content_doc → Send to viewers (they need content)
├─ collaborative_doc → Bidirectional sync (comments)
├─ submissions_doc → Don't send to viewers (private)
└─ user_content_doc → Never sync (local only)
```

Same resource, five documents, five different sync behaviors - all determined by Permit facts.

### The Decision Function

For each document, the system evaluates:

**Step 1: Check local_only**
- Is this document marked `local_only` in either Permit?
- YES → Don't send (private to one peer)

**Step 2: Check our capability**
- What capability do we have on this document?
- `viewer` → Don't send (read-only, can't write updates)
- `collaborator` or `submitter` → Continue checking

**Step 3: Check send_full_snapshot**
- Is this document marked `send_full_snapshot`?
- YES → Send full snapshot (complete history)

**Step 4: Check their no_incoming_updates**
- Does their Permit say `no_incoming_updates` for this document?
- YES → Don't send (they don't want updates)

**Step 5: Check their capability**
- What capability do they have?
- `collaborator` → Send incremental updates (bidirectional sync)
- `viewer` → Send incremental updates (they can read)
- `submitter` → Don't send (append-only, doesn't receive)

**Result**: Send, don't send, or send full snapshot.

## Sync Facts

Sync facts are per-document flags in Permits that control sync behavior.

### Three Key Flags

**1. local_only**

Marks a document as private to one peer - never syncs to others.

```json
{
  "sync": {
    "local_only": ["user_content_doc", "draft_doc"]
  }
}
```

**Use case**: Private drafts, local cache, per-user data

**2. no_incoming_updates**

Peer doesn't want to receive updates for this document.

```json
{
  "sync": {
    "no_incoming_updates": ["archived_doc"]
  }
}
```

**Use case**: Archived content, static snapshots, one-time transfers

**3. send_full_snapshot**

Send complete document history, not just current state.

```json
{
  "sync": {
    "send_full_snapshot": ["submissions_doc"]
  }
}
```

**Use case**: Form submissions where you need all entries, audit logs

### Where Sync Facts Come From

**Defined in HUML templates** - the application developer specifies sync behavior in declarative templates.

**Embedded in Permits** - when creating Permits, sync facts from templates are included.

**Read by frontend** - applications read Permit facts to determine sync behavior.

**No backend hardcoding** - backend just reads the facts and executes.

## The Three Fundamental Merge Patterns

Extended Web applications are built by combining three fundamental merge patterns. These are not application features - they're the underlying merge capabilities that enable unlimited applications.

### Pattern 1: Pull-Only (Read-Only Sync)

**Merge behavior**: Publisher updates, viewers receive, viewers cannot send changes back.

**Sync direction**: Unidirectional (publisher → viewer)

**Permit capability**: `viewer`

**What happens**:
1. Publisher edits document locally
2. Loro CRDT exports current state
3. Publisher syncs to viewers (Permit-driven filtering)
4. Viewers receive and merge updates
5. Viewers cannot send modifications back (Permit facts prevent it)

**Loro merge**: Viewers import CRDT snapshot, update local state

**Sample applications**: Blogs, newsletters, announcements, public content, read-only dashboards, documentation

### Pattern 2: Push-Only (Append-Only Sync)

**Merge behavior**: Viewers submit, publisher receives, viewers don't see others' submissions.

**Sync direction**: Unidirectional (viewer → publisher)

**Permit capability**: `submitter`

**What happens**:
1. Viewer creates new content locally
2. Loro CRDT creates append operation
3. Viewer sends to publisher (full snapshot via `send_full_snapshot` flag)
4. Publisher receives and merges with Loro CRDT
5. Viewer does NOT receive others' submissions (Permit facts prevent)

**Loro merge**: Publisher imports append operations, Loro handles ordering and deduplication

**Sample applications**: Forms, surveys, polls, feedback collection, submissions, voting systems

**Special behavior**: Uses `send_full_snapshot: true` in Permit facts to send complete document history for proper CRDT merging

### Pattern 3: Bidirectional (Collaborative Sync)

**Merge behavior**: All participants edit, Loro CRDT merges automatically, everyone converges.

**Sync direction**: Bidirectional (everyone ↔ everyone)

**Permit capability**: `collaborator`

**What happens**:
1. Any participant edits document locally
2. Loro CRDT records operations
3. All participants exchange CRDT operations
4. Loro automatically merges using conflict-free algorithms
5. Everyone converges to identical state (eventually consistent)

**Loro merge**: Multi-way CRDT merge, automatic conflict resolution, commutative operations ensure consistency

**Sample applications**: Messaging, group threads, collaborative editing, password sharing, multiplayer games, real-time workspaces, shared task lists

### Combining Patterns: Multi-Document Resources

Resources can have multiple documents, each with different merge patterns:

**Blog Post Example**:
```
Resource: "My Article"
├─ content_doc → Pull-only (viewers read article)
├─ comments_doc → Bidirectional (viewers collaborate on comments)
└─ reactions_doc → Push-only (viewers submit reactions, can't see others)
```

**Survey Platform Example**:
```
Resource: "Customer Survey"
├─ questions_doc → Pull-only (viewers see questions)
├─ responses_doc → Push-only (viewers submit, can't see others)
└─ summary_doc → Pull-only (publisher shares aggregated results)
```

**Multiplayer Game Example**:
```
Resource: "Chess Match"
├─ game_state_doc → Pull-only (viewers see board state)
├─ moves_doc → Bidirectional (players collaborate on moves)
└─ chat_doc → Bidirectional (players chat)
```

### Pattern Definition via HUML Templates

HUML templates define which pattern to use per document:

```yaml
documents:
  - name: content_doc      # Custom name, not hardcoded
    capability: viewer      # Pull-only pattern
    merge: loro_crdt

  - name: comments_doc     # Custom name
    capability: collaborator  # Bidirectional pattern
    merge: loro_crdt

  - name: submissions_doc  # Custom name
    capability: submitter    # Push-only pattern
    merge: loro_crdt
    sync:
      send_full_snapshot: true  # Required for append-only
```

**The patterns are fundamental primitives. Applications are combinations of these patterns with custom document names and Permit configurations.**

## Bidirectional Filtering

Both sender and receiver filter documents - sync is a two-way agreement.

### Sender-Side Filtering

Before sending:
1. Check our Permit: "Can I send this document?"
2. Check `local_only`: "Is this private to me?"
3. Check our capability: "Do I have write permissions?"
4. Build filtered resource with only sendable documents

### Receiver-Side Filtering

After receiving (for validation):
1. Check their Permit: "Are they authorized to send this?"
2. Check document capabilities: "Do they have permissions?"
3. Validate cryptographic signatures
4. Accept or reject

**If sender and receiver disagree**, the sync fails - both must have compatible Permits.

## Loro CRDT - Automatic Merging

Extended Web applications use **Loro** for conflict-free synchronization.

### What Are CRDTs?

CRDT = Conflict-Free Replicated Data Type

Traditional sync systems need a server to resolve conflicts:
```
Alice edits: "Hello world"
Bob edits: "Hello Bob"
→ Server decides which wins or asks user
```

Loro CRDTs merge automatically using mathematical rules:
```
Alice edits: "Hello world"
Bob edits: "Hello Bob"
→ Loro merges to deterministic result
→ All participants converge to same state
```

### How Loro Works

**1. Local edits**:
- You edit document on your device
- Loro records operation (insert, delete, etc.)
- Update happens instantly locally

**2. Sync operations**:
- When connected, send operations to peers
- Peers receive and apply operations
- Loro's merge algorithm ensures consistency

**3. Eventually consistent**:
- All participants eventually see same state
- Order doesn't matter (commutative operations)
- Works offline, syncs when reconnected

### Incremental vs Full Snapshots

**Incremental** (default):
- Send current document state
- Efficient for most use cases
- Viewers/collaborators get current version

**Full snapshot** (for submitters):
- Send complete operation history
- Needed for proper CRDT merging
- Ensures all submissions are included

## Frontend-Driven Merge Logic

The merge behavior is defined in HUML templates and read by the frontend, not hardcoded in the backend.

### Example: Comment Thread Template

```yaml
# HUML template defines documents
documents:
  - name: content_doc
    capability: viewer  # Viewers can read
    sync:
      direction: unidirectional  # Publisher → viewer only

  - name: comments_doc
    capability: collaborator  # Everyone can comment
    sync:
      direction: bidirectional  # Everyone ↔ everyone
      merge: loro_crdt  # Automatic CRDT merge
```

**Frontend reads this template** when creating Permits and configuring sync.

**Backend just executes** what the Permits specify.

**Infinitely customizable** - different templates define different merge behaviors.

## Security and Privacy

### Encrypted Sync

All sync'd content is encrypted:
1. Document is cloned via Loro export
2. Serialized to JSON
3. Re-encrypted for recipient's PGP public key
4. Sent over encrypted QUIC connection

**Double encryption**: QUIC encrypts transport, PGP encrypts content.

### Forward Secrecy

When delegating, content is re-encrypted for each recipient.

If someone's Permit is compromised:
- They can't decrypt content sent to others
- Previous sessions remain secure
- Only their own delegations are affected

### Authorization Validation

Every sync includes the Permit:
1. Peer validates cryptographic signature
2. Checks that Permit grants required capabilities
3. Verifies document-level permissions
4. Only accepts if everything checks out

**No Permit = no sync** - purely cryptographic authorization.

## Sync Flow Example

Here's a complete sync flow between owner and viewer:

### Step 1: Owner Publishes to Node

1. Owner creates resource with 3 documents
2. Owner's Permit specifies which documents to send
3. System filters: template_doc (send), content_doc (send), user_content_doc (local_only, don't send)
4. Encrypted filtered resource sent to node
5. Node validates and stores

### Step 2: Viewer Requests from Node

1. Viewer connects with shareable link Permit
2. Node creates viewer-specific Permit (via delegation)
3. Viewer's Permit specifies: template_doc (viewer), content_doc (viewer), comments_doc (collaborator)
4. System filters based on dual-Permit validation
5. Encrypted documents sent to viewer

### Step 3: Viewer Collaborates on Comments

1. Viewer adds comment to comments_doc
2. Loro records operation locally
3. Viewer syncs to node (bidirectional, collaborator capability)
4. Node receives, Loro merges automatically
5. Node syncs to other viewers
6. Everyone sees comment

### Step 4: Offline/Online Transitions

1. Viewer goes offline, adds more comments
2. Comments stored locally in Loro document
3. Viewer reconnects
4. Loro syncs operations
5. Automatic merge, everyone converges

**All of this driven by Permit facts** - no hardcoded sync logic.

## Why This Matters

Permit-driven sync enables:

**Flexibility** - New sync models don't require code changes

**Document-level control** - Different documents, different behaviors

**Data-driven** - HUML templates define sync, not backend code

**Decentralized** - Both peers validate independently

**Conflict-free** - Loro CRDTs merge automatically

**Secure** - Cryptographic validation, encrypted transport

**Customizable** - Infinite permission combinations possible

This is what makes Extended Web applications truly flexible - sync reads its behavior from data, not code.
