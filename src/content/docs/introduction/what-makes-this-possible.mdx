---
title: "What Makes This Possible"
description: "The technological breakthroughs that enable sovereign applications"
---

## The Identity Paradigm Shift

Traditional applications required third-party identity authorities to protect servers from adversarial clients. Without authentication, malicious users could abuse server resources, spam systems, or overwhelm infrastructure. Companies like Google provided convenient SSO solutions that verified legitimate users while handling the complexity of identity management.

This created centralized bottlenecks where all users converge on single points of control - Google's authentication servers, the application's central database, shared infrastructure that everyone depends on.

**Peer-to-peer connections flip this model entirely.**

Instead of all users connecting through central servers, trusted peers connect directly to each other. You collaborate only with people you explicitly choose to trust - there's no shared infrastructure that unknown parties can abuse. The fundamental shift is from universal access (anyone can use the service if they authenticate) to selective trust (you only connect with chosen collaborators).

## Absolutely Free by Design

Osvauld applications are fundamentally free because there are no ongoing server costs. Traditional applications require massive infrastructure - cloud storage, compute servers, databases, content delivery networks, and support staff. These costs get passed to users through subscriptions or advertising.

Since Osvauld applications run entirely peer-to-peer, there's nothing to host. No monthly AWS bills, no database licensing fees, no bandwidth charges. The applications are completely free by design - no purchase required, no subscriptions, no hidden costs.

Currently, there's one centralized dependency - Iroh's node resolution service that helps peers find each other initially. But even this can be decentralized as the technology matures, removing the last external infrastructure requirement.

## Solving the Synchronization Problem

The biggest limitation of traditional P2P systems was synchronization gaps. You could access and edit documents when offline, but if your collaborator made changes while you were disconnected, you wouldn't receive those updates until they came back online at the same time as you.

This created frustrating scenarios where changes would get stuck on offline devices, requiring both peers to be online simultaneously to sync updates - massively affecting the user experience.

**Personal nodes solve this with affordable always-on infrastructure.**

With single-board computers like the Orange Pi 6 Plus becoming incredibly cheap and capable, you can run your own dedicated device for backup and synchronization. These aren't servers in the traditional sense - they're your personal infrastructure that you control completely.

Your personal node can decrypt and store copies of your documents, ensuring everything stays synced with the latest changes. It buffers updates from offline collaborators, helps merge changes effectively, and assists peers in finding each other. Multiple users can share a single node, splitting costs while maintaining individual data sovereignty.

The Orange Pi 6 Plus also includes an NPU (Neural Processing Unit) for future AI capabilities like image processing, video transcoding, and local voice commands - but these are enhancements, not requirements for core functionality.

## Cryptographically-Backed Permissions

Traditional applications use Access Control Lists (ACLs) - simple lists of who can access what. These lists aren't cryptographically verified, meaning servers can modify permissions arbitrarily or administrators can bypass restrictions.

Extended Web applications use **Permits** - cryptographically signed authorization tokens that work like smart contracts for permissions. When you grant someone access to a document, you're creating mathematical proof of that permission.

Permits evolved from UCAN (User Controlled Authorization Networks) into a facts-only, data-driven design where:
- All authorization logic is encoded in verifiable facts
- Applications read Permit facts to determine behavior
- No permission server is needed for validation
- Permissions can't be forged or modified without your cryptographic signature

This is decentralized authorization - the same concept as blockchain smart contracts, but for personal applications.

## Reliable Peer-to-Peer Connections

Earlier P2P attempts failed because connecting peers reliably across the internet was nearly impossible. NAT traversal, firewall penetration, and peer discovery were unsolved problems.

Modern networking protocols like Iroh solve this. Built on QUIC with sophisticated NAT traversal and DHT-based discovery, direct peer connections now work as reliably as traditional client-server connections. Users connect to each other without requiring servers in the middle.

## Conflict-Free Collaboration

Real-time collaboration without servers requires solving the fundamental problem of conflicting edits. When multiple people edit simultaneously, whose changes should win?

Conflict-free Replicated Data Types (CRDTs) solve this mathematically. Extended Web applications use **Loro** - a high-performance CRDT library that guarantees all participants converge to identical states regardless of edit timing or network conditions.

Unlike traditional operational transforms that require server coordination, Loro CRDTs work entirely peer-to-peer. Your edits merge automatically with collaborators' changes, even when you're offline. This enables Google Docs-level collaboration performance without centralized servers.

## Safe Interactivity Without JavaScript

**The Security Problem**: Every application needs interactivity - reactive UI, state updates, conditional rendering, data transformations. But exposing JavaScript to users is a massive security threat:

- **Arbitrary code execution** - Users could run any code, access system resources
- **DOM manipulation** - Direct access to page structure and user data
- **Network requests** - Steal data, communicate with external servers
- **No sandboxing** - Full access to browser APIs
- **Side effects** - Can modify global state, corrupt application behavior

**Traditional web apps** expose JavaScript because they have no choice. **Extended Web applications use CEL instead.**

### CEL: Sandboxed, Safe Expressions

**CEL (Common Expression Language)** provides interactivity without security risks:

**Security Properties**:
- **Sandboxed** - Cannot access arbitrary functions or system resources
- **Side-effect free** - Expressions cannot modify state, only compute values
- **Deterministic** - Same inputs always produce same outputs
- **Limited scope** - Only accesses data explicitly provided
- **No network access** - Cannot make external requests
- **No file system** - Cannot read/write files
- **No DOM manipulation** - Cannot access page structure

**What CEL Can Do** (safely):
- Compute values from data: `total = (quantity * price) * (1 - discount)`
- Conditional logic: `showShipping = (productType == "physical")`
- Data transformations: `upperName = name.upper()`
- List operations: `items.filter(item, item.price > 100)`

**What CEL Cannot Do** (by design):
- Execute arbitrary code
- Access browser APIs
- Make network requests
- Modify global state
- Access the file system
- Manipulate the DOM

### HUML: Declarative Structure

**HUML templates** define structure declaratively, not imperatively:

**Instead of** writing JavaScript code that manipulates the DOM:
```javascript
// Unsafe - arbitrary code execution
document.querySelector('.title').innerHTML = userInput;
fetch('/api/data').then(r => r.json());
```

**You write** declarative templates with safe CEL expressions:
```yaml
# Safe - declarative structure
Text:
  content: "{{title}}"  # CEL expression, sandboxed
  when: "{{isVisible}}"  # CEL condition
```

HUML provides:
- Predefined block types (Text, Button, Form, etc.)
- Data binding via CEL expressions
- No arbitrary code execution
- Controlled interactivity

### High-Performance AND Secure

**OCaml Transpiler**: Compiles HUML + CEL to WebAssembly for performance:
- **40x faster** than equivalent JavaScript
- **60 FPS rendering** with 10,000+ expressions
- **Zero-copy GPU upload** for efficient graphics
- **Canvas shader compilation** - CEL expressions compile to GLSL shaders (500+ FPS)

**Why This Matters**:

You get **both** security AND performance:
- CEL provides safe interactivity (sandboxed, no arbitrary code)
- OCaml compilation provides speed (WebAssembly, GPU shaders)
- HUML provides structure (declarative, not imperative)

**Every app needs interactivity. Exposing JavaScript is a security threat. CEL + HUML provide safe interactivity that's also faster.**

## Why Now?

Several factors have converged to make Extended Web applications practical:

**AI Development Tools**: With AI assistance, small teams can build sophisticated applications without massive engineering overhead. Users can even use cloud AI (ChatGPT, Claude) with HUML guides to generate custom templates.

**Mature Desktop Frameworks**: Tools like Tauri enable building native desktop applications with web technologies, combining the best of both worlds without browser limitations.

**WebAssembly Maturity**: WASM enables near-native performance for compiled languages in browsers, making OCaml transpilation viable.

**Network Infrastructure Evolution**: Modern internet infrastructure better supports direct peer connections through protocols like Iroh, making P2P reliable.

**User Privacy Awareness**: Individuals increasingly value applications that don't track or monetize their behavior.

## The Result

Extended Web applications work like traditional software but operate fundamentally differently:

- **Direct peer-to-peer connections** instead of centralized servers
- **Cryptographic identity** instead of corporate authentication
- **Loro CRDT merging** instead of server-mediated conflict resolution
- **Permit-based authorization** instead of platform policies
- **Data-driven configuration** instead of hardcoded business logic
- **WebAssembly performance** instead of interpreted JavaScript

This architecture isn't limited to publishing. The same principles enable secure messaging, collaborative editing, file synchronization, and any application where individuals need to work together without surrendering control to intermediaries.

**The technology is ready. The Extended Web is here.**

